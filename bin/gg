#!/usr/bin/env bash

# Setup.
VERSION="0.0.1"

# Colors, formatting, etc.
normal() {
	printf "$1"
}

success() {
	printf "\e[0;32m$1\e[0m"
}

success_bold() {
	printf "\e[1;32m$1\e[0m"
}

success_underline() {
	printf "\e[4;32m$1\e[0m"
}

notice() {
	printf "\e[0;33m$1\e[0m"
}

notice_bold() {
	printf "\e[1;33m$1\e[0m"
}

notice_underline () {
	printf "\e[4;33m$1\e[0m"
}

whoops() {
	printf "\e[1;31m$1\e[0m"
}

whoops_subtext() {
	printf "\e[0;31m$1\e[0m"
}

log() {
	printf "\e[2m%s\e[22m \e[2m\e[90m|\e[22m\e[0m \e[32m%s\e[0m\n" "$1" "$2"
}

log_active() {
	printf "\e[3m%s\e[22m \e[2m\e[90m|\e[22m\e[0m \e[33m%s\e[0m\n" "$1" "$2"
}

# Utilities.
latest_commit_hash() {
	git rev-parse --short HEAD
}

latest_commit_message() {
	git log -1 --pretty=%B
}

current_branch() {
	git symbolic-ref --short HEAD
}

current_remote() {
	git config --get remote.origin.url
}

# Commands.

version() {
	success "gg"
	normal " version "
	notice "$VERSION\n"
}

init() {
	output=($(git init))

	success "[✔]"
	success_bold " ${output[0]} "
	success "${output[1]} Git repository.\n"
}

ignore_list() {
	list=$(curl --silent "https://www.gitignore.io/api/list")
	list=(${list//,/ })

	for ignore in "${list[@]}"; do
		normal "|- $ignore\n"
	done

	notice "\n[~] You must enter one of the templates or languages listed above.\n"
}

ignore() {
	if [ -z $1 ]; then
		ignore_list
	else
		ignore=$(curl --silent "https://www.gitignore.io/api/$1")
		ignore_array=($ignore)

		if [ ${ignore_array[5]} == "ERROR:" ]; then
			whoops "[✖] Template $1 does not exist.\n\n"

			ignore_list
		else
			if [[ -s ".gitignore" ]]; then
				echo -e	 "\n" >> .gitignore
			fi

			echo "$ignore" >> .gitignore
		fi
	fi
}



clone() {
	if [ -z $1 ]; then
		notice "[~] You must enter a repository URL or GitHub project (username/repository).\n"
	else
		URL=(${1//:/ })
		PROTOCOL=${URL[0]}

		if [ "${URL[1]:0:2}" != "//" ]; then
			URL_FIXED="https://github.com/${URL[@]}.git"
			PROTOCOL="https"
		else
			URL_FIXED="$1"
		fi

		notice "[~] Cloning from"
		notice_bold " $URL_FIXED "
		notice "over"
		notice_bold " $PROTOCOL"
		notice "...\n"

		OUTPUT=$((git clone "$URL_FIXED" --quiet) 2>&1)
		if [ $? -eq 0 ]; then
			success "\n[✔] Cloned into"

			URL_ARRAY=(${URL_FIXED//\// })
			URL_LAST_PART=${URL_ARRAY[${#URL_ARRAY[@]} - 1]}

			success_bold " ${URL_LAST_PART%????}.\n"
		else
			whoops "\n[✖] Could not clone repository.\n"
			whoops_subtext "    $OUTPUT\n"
		fi
	fi
}

add() {
	if [ -z $1 ]; then
		git add -A

		success "[✔] Added everything!\n"
	else
		for file in $@; do
			if [ -e $file ]; then
				git add $file

				success "[✔] Added"
				success_bold " $file"
				success "!\n"
			else
				whoops "[✖] Could not add $file.\n"
			fi
		done
	fi
}

commit() {
	add

	commitNoAdd
}

commitNoAdd() {
	if [ -z $1 ]; then
		message=$(git diff --name-only --cached)
		message="Added ${message//$'\n'/, }."
	else
		message="$@"
	fi

	OUTPUT=$(git commit -m "$message")
	if [ $? -eq 0 ]; then
		success "[✔] Committed!\n\n"

		hash="$(latest_commit_hash)"

		branch="$(current_branch)"

		message="$(latest_commit_message)"
		message_array=()
		while read -r line; do
			message_array+=("$line")
		done <<< "$message"
		message_fixed="${message_array[0]}"
		if [ ${#message_array[@]} -gt 1 ]; then
			message_fixed="$message_fixed (...)"
		fi

		printf "\e[2m\e[90m[\e[22m\e[0m$(success $branch)\e[2m\e[90m|\e[22m\e[0m$(notice $hash)\e[2m\e[90m]\e[22m\e[0m \e[90m$message_fixed\e[39m\n"
	elif [ $? -eq 1 ]; then
		notice "[~] Everything already committed.\n"
	else
		whoops "[✖] Could not commit changes.\n"
		whoops_subtext "    $OUTPUT\n"
	fi
}

push() {
	if [ -z $(git remote show) ]; then
		whoops "[✖] No remote to push to.\n"
	else
		notice "[~] Pushing"
		notice_bold " $(current_branch) "
		notice "branch"
		notice " to remote"
		notice_bold " $(current_remote)"
		notice "...\n\n"

		commits=$(git cherry --abbrev -v)

		OUTPUT=$((git push) 2>&1)
		if [ $? -eq 0 ]; then
			if [ "$OUTPUT" == "Everything up-to-date" ]; then
				success "[✔] All commits already pushed.\n"
			else
				success "[✔] Pushed!\n\n"

				commits_array=()
				while read -r line; do
					commits_array+=("$line")
				done <<< "$commits"

				for ((i=${#commits_array[@]} - 1; i >= 0; i--)); do
					commit=${commits_array[i]}
					commit_fixed=($commit)

					printf "\e[2m\e[90m[\e[22m\e[0m$(success $(current_branch))\e[2m\e[90m|\e[22m\e[0m$(notice ${commit_fixed[1]})\e[2m\e[90m]\e[22m\e[0m \e[90m${commit:10}\e[39m\n"
				done
			fi
		else
			whoops "[✖] Could not push commits.\n"
			whoops_subtext "    $OUTPUT\n"
		fi
	fi
}

pull() {
	if [ -z $(git remote show) ]; then
		whoops "[✖] No remote to pull from.\n"
	else
		notice "[~] Pulling"
		notice_bold " $(current_branch) "
		notice "branch"
		notice " from remote"
		notice_bold " $(current_remote)"
		notice "...\n\n"

		OUTPUT=$((git fetch --quiet) 2>&1)
		commits=$(git log --left-right --graph --cherry-pick --oneline master...origin/master)

		OUTPUT=$((git pull) 2>&1)
		if [ $? -eq 0 ]; then
			if [ "$OUTPUT" == "Already up-to-date." ]; then
				success "[✔] Everything is already up-to-date.\n"
			else
				success "[✔] Pulled!\n\n"

				commits_array=()
				while read -r line; do
					commits_array+=("$line")
				done <<< "$commits"

				for commit in "${commits_array[@]}"; do
					commit_fixed=($commit)

					printf "\e[2m\e[90m[\e[22m\e[0m$(success $(current_branch))\e[2m\e[90m|\e[22m\e[0m$(notice ${commit_fixed[1]})\e[2m\e[90m]\e[22m\e[0m \e[90m${commit:10}\e[39m\n"
				done
			fi
		else
			whoops "[✖] Could not pull commits.\n"
			whoops_subtext "    $OUTPUT\n"
		fi
	fi
}

pull
